<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PTCG Deck Showcase</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0c10;
      --panel: #12151b;
      --ink: #f3f5ff;
      --muted: #a0a7b9;
      --accent: #1f6fee;
      --line: #1c2230;
      --card-min-width: 96px;
      --card-gap: 8px;
      --card-max-rows: 3;
      --card-img-width: 72px;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #131926, #06070b 45%);
      color: var(--ink);
      min-height: 100vh;
    }
    a { color: inherit; }
    header {
      padding: 32px 24px 16px;
      text-align: center;
    }
    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.75rem, 2vw + 1rem, 2.4rem);
      letter-spacing: 0.04em;
    }
    header .meta {
      color: var(--muted);
      font-size: 0.95rem;
    }
    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px 64px;
      display: flex;
      flex-direction: column;
      gap: 32px;
    }
    #content {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 24px;
      align-items: start;
    }
    @media (max-width: 900px) {
      #content {
        grid-template-columns: 1fr;
      }
    }
    .status {
      text-align: center;
      margin-bottom: 16px;
      color: var(--muted);
      font-size: 0.95rem;
    }
    section.type-block {
      background: rgba(9, 11, 18, 0.76);
      border: 1px solid var(--line);
      border-radius: 13px;
      padding: 16px;
      box-shadow: 0 16px 36px rgba(5, 6, 10, 0.38);
      display: flex;
      flex-direction: column;
      gap: 14px;
      height: 100%;
    }
    section.type-block.type-block--energy {
      grid-column: 1 / -1;
    }
    section.type-block h2 {
      margin: 0;
      font-size: 1.3rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    section.type-block h2 span {
      color: var(--muted);
      font-size: 0.9rem;
      margin-left: 8px;
      text-transform: none;
    }
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--card-min-width), 1fr));
      grid-auto-rows: minmax(var(--card-min-height), auto);
      gap: var(--card-gap);
      flex: 1;
      align-content: start;
      max-height: calc(var(--card-min-height) * var(--card-max-rows) + var(--card-gap) * (var(--card-max-rows) - 1));
      overflow-y: auto;
      padding-right: 4px;
      scrollbar-gutter: stable;
    }
    .card-item {
      background: var(--panel);
      border: 1px solid #1f2534;
      border-radius: 9px;
      padding: 6px 6px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 5px;
      position: relative;
      min-height: var(--card-min-height);
      text-decoration: none;
      color: inherit;
    }
    .card-item:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .card-media {
      position: relative;
      display: inline-flex;
      justify-content: center;
      margin: 0 auto;
    }
    .card-media img {
      width: var(--card-img-width);
      max-width: 100%;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.42);
      background: #06070b;
    }
    .card-qty {
      position: absolute;
      right: 4px;
      bottom: 4px;
      background: var(--accent);
      color: white;
      font-size: 0.68rem;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 999px;
      box-shadow: 0 5px 13px rgba(18, 99, 237, 0.42);
      pointer-events: none;
      white-space: nowrap;
    }
    .card-item h3 {
      margin: 0;
      font-size: 0.98rem;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .card-item .details {
      color: var(--muted);
      font-size: 0.78rem;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .card-hover-preview {
      position: fixed;
      top: 50%;
      left: -9999px;
      transform: translateY(-50%) scale(0.94);
      opacity: 0;
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: none;
      z-index: 40;
      width: min(320px, 30vw);
    }
    .card-hover-preview.visible {
      opacity: 1;
      transform: translateY(-50%) scale(1);
    }
    .card-hover-frame {
      background: rgba(9, 11, 18, 0.92);
      border: 1px solid rgba(37, 48, 74, 0.9);
      border-radius: 16px;
      padding: 18px 18px 20px;
      box-shadow: 0 28px 60px rgba(5, 6, 10, 0.65);
    }
    .card-hover-frame img {
      display: block;
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 20px 48px rgba(0,0,0,0.52);
      background: #05060c;
    }
    .card-hover-info {
      margin-top: 14px;
      text-align: center;
      display: grid;
      gap: 6px;
      max-width: 100%;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    .card-hover-qty {
      font-size: 0.86rem;
      font-weight: 700;
      color: var(--accent);
      letter-spacing: 0.04em;
    }
    .card-hover-title {
      margin: 0;
      font-size: clamp(1.05rem, 0.8vw + 0.9rem, 1.25rem);
      letter-spacing: 0.02em;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    .card-hover-meta {
      margin: 0;
      font-size: 0.88rem;
      color: var(--muted);
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    .empty-state {
      text-align: center;
      padding: 64px 24px;
      border: 1px dashed var(--line);
      border-radius: 16px;
      color: var(--muted);
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <header>
    <h1 id="deckTitle">Deck Showcase</h1>
    <div class="meta" id="deckMeta"></div>
  </header>
  <main>
    <div id="status" class="status">Loading deck…</div>
    <div id="content"></div>
  </main>
  <script>
  (function(){
    const DATA_ROOT = './pokemon-tcg-data';
    const statusEl = document.getElementById('status');
    const contentEl = document.getElementById('content');
    const titleEl = document.getElementById('deckTitle');
    const metaEl = document.getElementById('deckMeta');
    const setMetadataCache = new Map();
    let setIndexPromise = null;

    const hoverPreview = createHoverPreview();
    const previewQuery = typeof window.matchMedia === 'function' ? window.matchMedia('(min-width: 1100px)') : null;
    const handlePreviewToggle = event => setPreviewMode(event.matches);
    setPreviewMode(previewQuery ? previewQuery.matches : true);
    if(previewQuery){
      if(typeof previewQuery.addEventListener === 'function'){
        previewQuery.addEventListener('change', handlePreviewToggle);
      } else if(typeof previewQuery.addListener === 'function') {
        previewQuery.addListener(handlePreviewToggle);
      }
    }

    const repositionPreview = () => {
      if(hoverPreview.active && hoverPreview.container.classList.contains('visible')){
        hoverPreview.position();
      }
    };
    window.addEventListener('resize', repositionPreview);
    document.addEventListener('scroll', repositionPreview, true);

    init().catch(err => {
      console.error(err);
      setStatus('Unable to load deck.');
    });

    async function init(){
      const params = new URLSearchParams(window.location.search);
      const deckURL = params.get('deck_url');
      if(!deckURL){
        setStatus('Provide a deck URL via the <code>deck_url</code> query string.');
        return;
      }
      setStatus('Fetching deck…');
      const deck = await fetchJSON(deckURL.trim());
      if(!deck?.cards?.length){
        setStatus('Deck is empty.');
        return;
      }
      titleEl.textContent = deck.name || 'Deck Showcase';
      metaEl.textContent = '';

      const ids = Array.from(deck.cards).map(c => c.id).filter(Boolean);
      const uniqueSetIds = Array.from(new Set(ids.map(extractSetId).filter(Boolean)));
      const cardMap = new Map();

      setStatus('Fetching card details…');
      await Promise.all(uniqueSetIds.map(setId => loadSet(setId, cardMap)));

      const typed = groupByType(deck.cards, cardMap);
      renderSections(typed);
      setStatus('');
    }

    function setStatus(message){
      if(!message){
        statusEl.textContent = '';
        statusEl.style.display = 'none';
      } else {
        statusEl.innerHTML = message;
        statusEl.style.display = '';
      }
    }

    async function fetchJSON(url){
      const res = await fetch(url, { cache: 'no-cache' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    function extractSetId(cardId){
      if(!cardId) return '';
      const match = String(cardId).match(/^([^-]+)/);
      if(match) return match[1];
      const trimmed = String(cardId).replace(/\d+.*$/, '');
      return trimmed || '';
    }

    async function loadSet(setId, cardMap){
      const paths = [
        `${DATA_ROOT}/cards/en/${setId}.json`,
        `${DATA_ROOT}/cards/${setId}.json`,
        `${DATA_ROOT}/${setId}.json`
      ];
      for(const path of paths){
        try {
          const res = await fetch(path, { cache: 'no-cache' });
          if(!res.ok) continue;
          const text = await res.text();
          const cards = normaliseSetJSON(text);
          if(!cards.length) continue;
          const setMeta = await getSetMetadata(setId);
          for(const card of cards){
            if(!card?.id) continue;
            hydrateCardSet(card, setId, setMeta);
            cardMap.set(card.id, card);
          }
          return;
        } catch (err) {
          console.warn('Set load failed', setId, err);
        }
      }
      console.warn('Set not found for', setId);
    }

    function normaliseSetJSON(text){
      try {
        const parsed = JSON.parse(text);
        if(Array.isArray(parsed)) return parsed;
        if(Array.isArray(parsed?.data)) return parsed.data;
        if(Array.isArray(parsed?.cards)) return parsed.cards;
        const values = Object.values(parsed || {}).filter(v => Array.isArray(v));
        if(values.length) return values.flat();
      } catch (err) {
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const manual = [];
        for(const line of lines){
          try {
            const item = JSON.parse(line);
            if(item && typeof item === 'object') manual.push(item);
          } catch (e) {}
        }
        if(manual.length) return manual;
      }
      return [];
    }

    async function getSetMetadata(setId){
      if(!setId) return null;
      const key = String(setId).toLowerCase();
      if(setMetadataCache.has(key)) return setMetadataCache.get(key);
      const index = await loadSetIndex();
      const match = index.find(item => String(item?.id || '').toLowerCase() === key) || null;
      setMetadataCache.set(key, match);
      return match;
    }

    async function loadSetIndex(){
      if(setIndexPromise) return setIndexPromise;
      const paths = [
        `${DATA_ROOT}/sets/en.json`,
        `${DATA_ROOT}/sets.json`,
        `${DATA_ROOT}/sets/all.json`
      ];
      setIndexPromise = (async () => {
        for(const path of paths){
          try {
            const res = await fetch(path, { cache: 'no-cache' });
            if(!res.ok) continue;
            const text = await res.text();
            const sets = normaliseSetMetaJSON(text);
            if(sets.length) return sets;
          } catch (err) {
            console.warn('Set metadata load failed', path, err);
          }
        }
        console.warn('Set metadata index not found.');
        return [];
      })();
      return setIndexPromise;
    }

    function normaliseSetMetaJSON(text){
      try {
        const parsed = JSON.parse(text);
        if(Array.isArray(parsed)) return parsed;
        if(Array.isArray(parsed?.data)) return parsed.data;
        if(Array.isArray(parsed?.sets)) return parsed.sets;
        const values = Object.values(parsed || {}).filter(v => Array.isArray(v));
        if(values.length) return values.flat();
      } catch (err) {
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const manual = [];
        for(const line of lines){
          try {
            const item = JSON.parse(line);
            if(item && typeof item === 'object') manual.push(item);
          } catch (e) {}
        }
        if(manual.length) return manual;
      }
      return [];
    }

    function hydrateCardSet(card, setId, meta){
      if(!card) return;
      const current = card.set && typeof card.set === 'object' ? { ...card.set } : {};
      const info = meta && typeof meta === 'object' ? { ...meta } : {};
      const merged = { ...info, ...current };
      merged.id = merged.id || info.id || setId || '';
      if(info.images || current.images){
        merged.images = { ...(info.images || {}), ...(current.images || {}) };
      }
      if(info.legalities || current.legalities){
        merged.legalities = { ...(info.legalities || {}), ...(current.legalities || {}) };
      }
      card.set = merged;
    }

    function groupByType(entries, cardMap){
      const buckets = new Map();
      for(const entry of entries){
        const card = cardMap.get(entry.id) || null;
        const type = card?.supertype || 'Other';
        if(!buckets.has(type)) buckets.set(type, []);
        buckets.get(type).push({ entry, card });
      }
      const order = ['Pokémon', 'Trainer', 'Energy'];
      const sorted = [];
      for(const key of order){
        if(buckets.has(key)) sorted.push([key, buckets.get(key)]);
        buckets.delete(key);
      }
      for(const [key, value] of buckets.entries()){
        value.sort(cardSorter);
        sorted.push([key, value]);
      }
      return sorted.map(([type, list]) => [type, list.slice().sort(cardSorter)]);
    }

    function cardSorter(a, b){
      const nameA = (a.card?.name || a.entry.id || '').toLowerCase();
      const nameB = (b.card?.name || b.entry.id || '').toLowerCase();
      if(nameA < nameB) return -1;
      if(nameA > nameB) return 1;
      return 0;
    }

    function setPreviewMode(enabled){
      hoverPreview.active = enabled;
      if(enabled){
        hoverPreview.container.removeAttribute('hidden');
      } else {
        hoverPreview.hide();
        hoverPreview.container.setAttribute('hidden', 'hidden');
      }
    }

    function createHoverPreview(){
      const container = document.createElement('aside');
      container.className = 'card-hover-preview';
      container.setAttribute('aria-hidden', 'true');
      container.setAttribute('hidden', 'hidden');

      const frame = document.createElement('div');
      frame.className = 'card-hover-frame';
      container.appendChild(frame);

      const img = document.createElement('img');
      img.alt = '';
      frame.appendChild(img);

      const info = document.createElement('div');
      info.className = 'card-hover-info';
      frame.appendChild(info);

      const qty = document.createElement('span');
      qty.className = 'card-hover-qty';
      info.appendChild(qty);

      const title = document.createElement('h3');
      title.className = 'card-hover-title';
      info.appendChild(title);

      const meta = document.createElement('p');
      meta.className = 'card-hover-meta';
      info.appendChild(meta);

      document.body.appendChild(container);

      const GAP = 18;

      const api = {
        container,
        img,
        qty,
        title,
        meta,
        active: false,
        currentTarget: null,
        show(data){
          if(!this.active) return;
          if(!data?.image){
            this.hide();
            return;
          }
          if(this.img.src !== data.image){
            this.img.src = data.image;
          }
          this.img.alt = data.title ? `${data.title} card image` : 'Card image';
          this.title.textContent = data.title || '';
          this.meta.textContent = data.meta || '';
          if(data.qty){
            this.qty.textContent = `×${data.qty}`;
            this.qty.style.display = '';
          } else {
            this.qty.textContent = '';
            this.qty.style.display = 'none';
          }
          this.currentTarget = data.element instanceof HTMLElement ? data.element : null;
          if(this.currentTarget){
            this.position();
          } else {
            const desiredWidth = Math.min(320, window.innerWidth * 0.3);
            const fallbackLeft = Math.max(GAP, (window.innerWidth - desiredWidth) / 2);
            const fallbackTop = Math.round(window.innerHeight / 2);
            this.container.style.left = `${fallbackLeft}px`;
            this.container.style.top = `${fallbackTop}px`;
          }
          this.container.classList.add('visible');
          this.container.setAttribute('aria-hidden', 'false');
        },
        hide(){
          this.container.classList.remove('visible');
          this.container.setAttribute('aria-hidden', 'true');
          this.container.style.left = '-9999px';
          this.currentTarget = null;
        },
        position(){
          if(!this.currentTarget || !this.currentTarget.isConnected){
            this.hide();
            return;
          }
          const rect = this.currentTarget.getBoundingClientRect();
          const desiredWidth = Math.min(320, window.innerWidth * 0.3);
          const currentRect = this.container.getBoundingClientRect();
          const previewWidth = currentRect.width || desiredWidth;
          let left = rect.right + GAP;
          const maxLeft = window.innerWidth - previewWidth - GAP;
          if(left > maxLeft){
            left = Math.max(GAP, rect.left - previewWidth - GAP);
          }
          const previewHeight = currentRect.height || 0;
          let top = rect.top + rect.height / 2;
          if(previewHeight){
            const half = previewHeight / 2;
            const maxTop = window.innerHeight - half - GAP;
            const minTop = half + GAP;
            top = Math.min(Math.max(top, minTop), maxTop);
          }
          this.container.style.left = `${Math.max(GAP, left)}px`;
          this.container.style.top = `${Math.round(top)}px`;
        }
      };

      img.addEventListener('load', () => {
        if(api.active && api.container.classList.contains('visible')){
          api.position();
        }
      });

      return api;
    }

    function renderSections(groups){
      if(!groups.length){
        contentEl.innerHTML = '<div class="empty-state">No card details available for this deck.</div>';
        return;
      }
      const frag = document.createDocumentFragment();
      for(const [type, cards] of groups){
        const section = document.createElement('section');
        section.className = 'type-block';
        if(type === 'Energy'){
          section.classList.add('type-block--energy');
        }
        const total = cards.reduce((sum, item) => sum + (Number(item.entry.qty) || 0), 0);
        const heading = document.createElement('h2');
        heading.textContent = type;
        const span = document.createElement('span');
        span.textContent = `${total} card${total === 1 ? '' : 's'}`;
        heading.appendChild(span);
        section.appendChild(heading);

        const grid = document.createElement('div');
        grid.className = 'card-grid';

        for(const item of cards){
          const el = createCardElement(item);
          grid.appendChild(el);
        }

        section.appendChild(grid);
        frag.appendChild(section);
      }
      contentEl.innerHTML = '';
      contentEl.appendChild(frag);
    }

    function createCardElement(item){
      const { entry, card } = item;
      const qty = Number(entry.qty) || 0;
      const wrapper = document.createElement('a');
      wrapper.className = 'card-item';
      wrapper.setAttribute('data-qty', `×${qty}`);
      wrapper.setAttribute('data-card-id', entry.id || '');

      const url = new URL('card-detail.html', window.location.href);
      if(entry?.id){
        url.searchParams.set('card_id', entry.id);
      }
      if(qty){
        url.searchParams.set('qty', qty);
      }
      wrapper.href = `${url.pathname}${url.search}`;

      const media = document.createElement('div');
      media.className = 'card-media';

      const img = document.createElement('img');
      const imgSrc = card?.images?.small || card?.images?.large || card?.imageUrl || '';
      if(imgSrc){
        img.src = imgSrc;
        img.alt = card?.name || entry.id;
      } else {
        img.alt = 'Image unavailable';
        img.style.opacity = '0.4';
      }
      media.appendChild(img);

      const qtyBadge = document.createElement('span');
      qtyBadge.className = 'card-qty';
      qtyBadge.textContent = `×${qty}`;
      media.appendChild(qtyBadge);

      wrapper.appendChild(media);

      const title = document.createElement('h3');
      title.textContent = card?.name || entry.id;
      wrapper.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'details';
      const metaParts = [];
      if(card?.set?.name) metaParts.push(card.set.name);
      if(card?.number) metaParts.push(`#${card.number}`);
      const metaText = metaParts.join(' ');
      meta.textContent = metaText;
      wrapper.appendChild(meta);

      const previewData = {
        image: card?.images?.large || card?.imageUrlHiRes || card?.imageUrl || card?.images?.small || '',
        title: title.textContent,
        meta: metaText || card?.name || entry.id,
        qty,
        element: wrapper
      };

      const showPreview = () => hoverPreview.show(previewData);
      const hidePreview = () => hoverPreview.hide();
      wrapper.addEventListener('mouseenter', showPreview);
      wrapper.addEventListener('mouseleave', hidePreview);
      wrapper.addEventListener('focus', showPreview);
      wrapper.addEventListener('blur', hidePreview);

      return wrapper;
    }
  })();
  </script>
</body>
</html>